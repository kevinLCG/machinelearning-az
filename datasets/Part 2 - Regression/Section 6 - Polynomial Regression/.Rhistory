# Realizamos la transpuesta porque scale lo hace para columnas y luego se volvio a la matriz original
logCPM <- t(scale(t(logCPM)))
# Cargamos una libreria para graficar
library(gplots)
# Graficamos en un heatmap los 30 genes que se encuentran mayormente diferencialmente expresados entre las muestras WT y las mutantes.
col.pan <- colorpanel(100, "blue", "white", "red")
heatmap.2(logCPM,col = col.pan, Rowv = T,scale = "none", cexRow = 1, cexCol = 1.4, density.info = "none", margin = c(.5,10), lhei = c(2,5), lwid = c(2,6))
# Guardamos en una tabla los genes DE
DE_genes <- lrt$table
head(DE_genes)
# Cargamos una libreria con la anotacion del genoma de la mosca para otener las posiciones de los genes de nuestro interes.
library(TxDb.Dmelanogaster.UCSC.dm6.ensGene)
txdb <- TxDb.Dmelanogaster.UCSC.dm6.ensGene
# Gardamos en dm.genes la parte de la anotacion completa del genoma que nos interesa (los genes).
dm.genes <- genes(txdb)
dm.genes
# Agregamos las columnas logFc y PValue de los "genes DE" obtenidos previamente a las anotaciones del los genes de la mosca.
mcols(dm.genes) <- DE_genes[names(dm.genes), c("logFC", "PValue")]
# Mostramos los primeros 4 genes
head(dm.genes, n=4)
# Cargamos una libreria para poder visualizar la localizacion de los genes diferencialmente expresados en los cromosomas de la mosca.
library(karyoploteR)
# Ocupamos la matriz previa con las anotaciones del genoma y la ordenamos por pvalue y aquellos genes que no cuentan con esta columna (que no forman parte de este analisis), quede hasta abajo.
ordered <- dm.genes[order(dm.genes$PValue, na.last = TRUE),]
# Le indicamos a la libreria que estamos trabajando con Drosophila
kp <- plotKaryotype(genome="dm6")
# Mapeamos los 10 primeros genes en el genoma de la mosca
kp <- kpPlotMarkers(kp, ordered[1:10], labels = names(ordered[1:10]), text.orientation = "horizontal")
length(dm.genes)
# Nos quedamos con la anotacion unicamente de aquellos genes diferencialmente expresados y eliminamos todos los demas genes de Drosophila.
filtered.dm.genes <- dm.genes[!is.na(dm.genes$PValue)]
log.pval <- -log10(filtered.dm.genes$PValue)
# Le añadimos a nuestra tabla una columna con el -log10 del pvalue
mcols(filtered.dm.genes)$log.pval <- log.pval
filtered.dm.genes
# Obtenemos el Top 20 de genes.
top.genes <- ordered[1:20]
# Guardamos la imagen con el mapeo de los "genes DE" en los cromosomas de la mosca
png(filename = "Location_Dgenes.png", width = 3840, height = 2200)
# Filtramos los genes para quedarnos solamente con aquellos que tienen un pvalue menor a 0.05
sign.genes <- filtered.dm.genes[filtered.dm.genes$PValue < 0.05,]
# Determinamos las escalas que se utilizaran en el plot a partir de
fc.ymax <- ceiling(max(range(sign.genes$logFC)))
fc.ymin <- -fc.ymax
# Hacemos algunos ajustes del plot
pp <- getDefaultPlotParams(plot.type = 2)
pp$leftmargin <- 0.15
pp$topmargin <- 40
pp$bottommargin <- 15
pp$ideogramheight <- 5
pp$data1inmargin <- 10
pp$data1outmargin <- 0
col.over <- "#FFBD07AA"
col.under <- "#00A6EDAA"
sign.col <- rep(col.over, length(sign.genes))
sign.col[sign.genes$logFC<0] <- col.under
ordered <- dm.genes[order(sign.genes$PValue, na.last = TRUE),]
top.genes <- ordered[1:20]
kp <- plotKaryotype(genome="dm6", plot.type=2, cex=4)
cex.val <- sqrt(sign.genes$log.pval)
points.top <- 0.8
# REALIZAMOS EL PLOT
# Pane l1 - Circulos que representan el nivel de expresion de los genes
kpPoints(kp, data=sign.genes, y=sign.genes$logFC, cex=cex.val*2, ymax=fc.ymax, ymin=fc.ymin, r1=points.top, col=sign.col)
kpAxis(kp, ymax=fc.ymax, ymin=fc.ymin, r1=points.top)
kpAddLabels(kp, labels = "log FC", cex=4.5, srt=90, pos=3, label.margin = 0.02, ymax=fc.ymax, ymin=fc.ymin, r1=0.8)
gene.mean <- start(top.genes) + (end(top.genes) - start(top.genes))/2
kpSegments(kp, chr=as.character(seqnames(top.genes)), x0=gene.mean, x1=gene.mean, y0=top.genes$logFC, y1=fc.ymax, ymax=fc.ymax, ymin=fc.ymin, r1=0.8, cex = 2)
kpPlotMarkers(kp, top.genes, labels = names(top.genes), cex=4, text.orientation = "horizontal", r0=0.4)
# Panel 2 - Densidad genica a lo largo de los cromosomas
kp <- kpPlotDensity(kp, data=dm.genes, window.size = 10e4, data.panel = 2)
lrt$table[13,]
library(org.Dm.eg.db)
entrez_duplicados <- mapIds(org.Dm.eg.db,
keys= row.names(lrt$table),
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
# Quitamos de la tabla a quellos FLYID que referencien al mismo ENTREZID y a aquellos FLYID que no tengan un ENTREZID
lrt$table <- lrt$table[!duplicated(entrez_duplicados),]
lrt$table <- lrt$table[-13,]
entrez <- mapIds(org.Dm.eg.db,
keys= row.names(lrt$table),
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
rownames(lrt$table) <- entrez
## Biological Process
go <- goana(lrt, species="Dm")
BiocManager::install("GO.db")
# Cargamos una libreria para obtener un enriquecimiento por GO
library(GO.db)
# Cargamos una libreria para obtener un enriquecimiento por GO
library(GO.db)
## Biological Process
go <- goana(lrt, species="Dm")
topGO(go, ont="BP", sort="Up", n=30, truncate=30)
## Molecular Function
go <- goana(lrt, species="Dm")
topGO(go, ont="MF", sort="Up", n=30, truncate=30)
## Cellular component
go <- goana(lrt, species="Dm")
topGO(go, ont="CC", sort="Up", n=30, truncate=30)
library(limma)
library(Glimma)
library(gplots)
library(RColorBrewer)
# Cargamos la libreria a usar
library(edgeR)
# Cargamos los datos
rawCount <- read.delim("~/2019-3_Tercer_Semestre/R/Proyecto_Final/rawCountMatrix.csv", stringsAsFactors=FALSE)
# Visualizamos la forma en que estan organiazdos nuestros datos
str(rawCount)
# Guardamos en ExpDiff los datos leidos anteriormente, dejando solo las 4 cuentas de RNASeq y quitando el nombre del gen y los simbolos
ExpDiff <- rawCount[,c(-1,-2)]
# Ponemos el nombre de los geners como el nombre de as filas de la matriz con la expresion diferencial
rownames(ExpDiff) <- rawCount[,1]
head(ExpDiff)
# Checamos que efectivamente sean la misma cantidad de genes que los que se leyeron
nrow(ExpDiff)
# Obtenemos las cuentas por millon (CPM).
cpm_log <- cpm(ExpDiff, log = TRUE)
# Obtenemos la mediana de expresión para cada uno de los genes y la graficamos.
median_log2_cpm <- apply(cpm_log, 1, median)
blue_red <- colorRampPalette(c("blue","red"))
hist(median_log2_cpm, main = "Mediana de expresion - CPM", xlab = "mediana log2,cpm", ylab = "Frecuencia", col = blue_red(14))
# Definimos un threshold de expresion y nos quedaremos con aquellos genes cuyo log2, cpm sea mayor a cero. Aquellos debajo de este valor se expresan en extremadamente poco.
expr_cutoff <- 0
abline(v = expr_cutoff, col = "red", lwd = 3)
## LIMPIAMOS NUESTRO DATA SET
# Nos quedamos unicamente con aquellos genes cuya mediana se mayor al valor de corte establecido anteriormente (cero).
data_clean <- ExpDiff[median_log2_cpm > expr_cutoff, ]
cat("Tenemos ",nrow(data_clean), " genes cuya expresion no es despreciable.")
# Nuevamente realizamos la normalizacion de los valores de expresion por CPM, obtenemos su mediana y la graficamos.
cpm_lognorm <- cpm(data_clean, log = TRUE)
median_log2_cpm2 <- apply(cpm_lognorm, 1, median)
green_yellow <- colorRampPalette(c("chartreuse4","yellow"))
hist(median_log2_cpm2, main = "Mediana de expresion - CPM", xlab = "mediana log2,cpm", ylab = "Frecuencia", col = green_yellow(12))
# Realizamos un heatmap para ver de manera gráfica la correlacion entre los niveles de expresion entre las 4 condiciones:
# NULL A - mosca mutante 1
# NULL B - mosca mutante 2
# WT_gsm131539 - mosca silvestre 1
# WT_gsm131540 - mosca silvestre 2
heatmap(cor(cpm_lognorm), cexRow = 0.65, cexCol = 0.6)
# Realizamos un analisis de componentes principales (PCA) para ver como se separan las 4 muestras de mosca a partir de los niveles de expresion de los genes. Se espera que se agrupen aquellas muestras de tejido WT.
pca <- prcomp(t(cpm_lognorm), scale. = TRUE)
summary(pca)
# realizamos un plot para ver la distribucion de las 4 muestras.
plot(pca$x[, 1], pca$x[, 2], pch = ".", xlab = "PC1", ylab = "PC2")
text(pca$x[, 1], pca$x[, 2], labels = c("WT400","WT399","N_A","N_B"))
# Calcular la varianza
var_genes <- apply(cpm_lognorm, 1, var)
# Seleccionar los transcritos que muestran mayor varianza
select_var <- names(sort(var_genes, decreasing=TRUE))[1:20]
highly_variable_lcpm <- cpm_log[select_var,]
library(limma)
library(Glimma)
library(gplots)
library(RColorBrewer)
# Elegir la paleta de colores
mypalette <- brewer.pal(11,"RdYlBu")
morecols <- colorRampPalette(mypalette)
# Hacer el heatmap
heatmap.2(highly_variable_lcpm, col=rev(morecols(20)),trace="none", main="Top 20 más variables entre las muestras",  scale="row")
# Obtenemos la primera letra de los grupos; "W" haciendo referencia a wild-type y "N" a mutante.
group <- substr(colnames(data_clean), 1, 1)
# Creamos un objeto DGEList a partir de la tabla de cuentas
# library size - indica el numero total de cuentas de todos los genes que tiene cada grupo
# norm.factors - indica la cantidad de factores de normalizacion que modifican los tamaños de las librerias.
y <- DGEList(counts = data_clean, group = group)
y
# Hacemos un scatterplot bidimensional, en donde las distancias se aproximan al log2 fold changes entre las muestras.
plotMDS(y)
# Creamos una matriz, donde se encuentran los datos anteriores, pero de una forma para que EdgeR los pueda leer.
design <- model.matrix(~group, data=y$samples)
design
# LLamamos a una funcion que maximiza la verosimilitud binomial negativa para dar un estimado de la dispersion entre las etiquetas.
y <- estimateDisp(y, design)
sqrt(y$common.dispersion)
# Graficamos el coeficiente de variacion biologico (BCV) contra la abundancia (en log2 cpm).
plotBCV(y)
# Calculamos los factores de normalizacion para escalar los tamaños de libreria crudos.
y <- calcNormFactors(y)
y$samples
# Ajustamos un modelo lineal-log generalizado negativo binomial para leer las cuentas para cada gen.
fit <- glmFit(y, design)
lrt <- glmLRT(fit)
# Extraemos las etiquetas DE top del dataframe, ordenadas por p-value.
topTags(lrt)
# Ordenamos de acuerdo al p-value y obtenemos 10 genes con los mejores p-values.
o <- order(lrt$table$PValue)
cpm(y)[o[1:10],]
# Clasificamos estadisticos-t como: up, down y not significant.
summary(decideTests(lrt))
# Hacemos un sscatterplot bidimensional donde se muestran aquellos gener sobre- y sub-expresados.
plotMD(lrt, main= "DE genes")
abline(h=c(-1, 1), col="blue")
# Nuevamente normalizamos nuestros datos por CPM log2
logCPM <- cpm(y, prior.count=2, log=TRUE)
colnames(logCPM) <- paste(y$samples$group,1:2, sep = "=")
# Y obtenemos 30 genes con los mejores p-values
o <- order(lrt$table$PValue)
logCPM <- logCPM[o[1:30],]
# Centramos o escalamos los valores numericos de los genes.
# Realizamos la transpuesta porque scale lo hace para columnas y luego se volvio a la matriz original
logCPM <- t(scale(t(logCPM)))
# Cargamos una libreria para graficar
library(gplots)
# Graficamos en un heatmap los 30 genes que se encuentran mayormente diferencialmente expresados entre las muestras WT y las mutantes.
col.pan <- colorpanel(100, "blue", "white", "red")
heatmap.2(logCPM,col = col.pan, Rowv = T,scale = "none", cexRow = 1, cexCol = 1.4, density.info = "none", margin = c(.5,10), lhei = c(2,5), lwid = c(2,6))
# Guardamos en una tabla los genes DE
DE_genes <- lrt$table
head(DE_genes)
# Cargamos una libreria con la anotacion del genoma de la mosca para otener las posiciones de los genes de nuestro interes.
library(TxDb.Dmelanogaster.UCSC.dm6.ensGene)
txdb <- TxDb.Dmelanogaster.UCSC.dm6.ensGene
# Gardamos en dm.genes la parte de la anotacion completa del genoma que nos interesa (los genes).
dm.genes <- genes(txdb)
dm.genes
# Agregamos las columnas logFc y PValue de los "genes DE" obtenidos previamente a las anotaciones del los genes de la mosca.
mcols(dm.genes) <- DE_genes[names(dm.genes), c("logFC", "PValue")]
# Mostramos los primeros 4 genes
head(dm.genes, n=4)
# Cargamos una libreria para poder visualizar la localizacion de los genes diferencialmente expresados en los cromosomas de la mosca.
library(karyoploteR)
# Ocupamos la matriz previa con las anotaciones del genoma y la ordenamos por pvalue y aquellos genes que no cuentan con esta columna (que no forman parte de este analisis), quede hasta abajo.
ordered <- dm.genes[order(dm.genes$PValue, na.last = TRUE),]
# Le indicamos a la libreria que estamos trabajando con Drosophila
kp <- plotKaryotype(genome="dm6")
# Mapeamos los 10 primeros genes en el genoma de la mosca
kp <- kpPlotMarkers(kp, ordered[1:10], labels = names(ordered[1:10]), text.orientation = "horizontal")
length(dm.genes)
# Nos quedamos con la anotacion unicamente de aquellos genes diferencialmente expresados y eliminamos todos los demas genes de Drosophila.
filtered.dm.genes <- dm.genes[!is.na(dm.genes$PValue)]
log.pval <- -log10(filtered.dm.genes$PValue)
# Le añadimos a nuestra tabla una columna con el -log10 del pvalue
mcols(filtered.dm.genes)$log.pval <- log.pval
filtered.dm.genes
# Obtenemos el Top 20 de genes.
top.genes <- ordered[1:20]
# Guardamos la imagen con el mapeo de los "genes DE" en los cromosomas de la mosca
png(filename = "Location_Dgenes.png", width = 3840, height = 2200)
# Filtramos los genes para quedarnos solamente con aquellos que tienen un pvalue menor a 0.05
sign.genes <- filtered.dm.genes[filtered.dm.genes$PValue < 0.05,]
# Determinamos las escalas que se utilizaran en el plot a partir de
fc.ymax <- ceiling(max(range(sign.genes$logFC)))
fc.ymin <- -fc.ymax
# Hacemos algunos ajustes del plot
pp <- getDefaultPlotParams(plot.type = 2)
pp$leftmargin <- 0.15
pp$topmargin <- 40
pp$bottommargin <- 15
pp$ideogramheight <- 5
pp$data1inmargin <- 10
pp$data1outmargin <- 0
col.over <- "#FFBD07AA"
col.under <- "#00A6EDAA"
sign.col <- rep(col.over, length(sign.genes))
sign.col[sign.genes$logFC<0] <- col.under
ordered <- dm.genes[order(sign.genes$PValue, na.last = TRUE),]
top.genes <- ordered[1:20]
kp <- plotKaryotype(genome="dm6", plot.type=2, cex=4)
cex.val <- sqrt(sign.genes$log.pval)
points.top <- 0.8
# REALIZAMOS EL PLOT
# Pane l1 - Circulos que representan el nivel de expresion de los genes
kpPoints(kp, data=sign.genes, y=sign.genes$logFC, cex=cex.val*2, ymax=fc.ymax, ymin=fc.ymin, r1=points.top, col=sign.col)
kpAxis(kp, ymax=fc.ymax, ymin=fc.ymin, r1=points.top)
kpAddLabels(kp, labels = "log FC", cex=4.5, srt=90, pos=3, label.margin = 0.02, ymax=fc.ymax, ymin=fc.ymin, r1=0.8)
gene.mean <- start(top.genes) + (end(top.genes) - start(top.genes))/2
kpSegments(kp, chr=as.character(seqnames(top.genes)), x0=gene.mean, x1=gene.mean, y0=top.genes$logFC, y1=fc.ymax, ymax=fc.ymax, ymin=fc.ymin, r1=0.8, cex = 2)
kpPlotMarkers(kp, top.genes, labels = names(top.genes), cex=4, text.orientation = "horizontal", r0=0.4)
# Panel 2 - Densidad genica a lo largo de los cromosomas
kp <- kpPlotDensity(kp, data=dm.genes, window.size = 10e4, data.panel = 2)
# Cargamos una libreria
library(org.Dm.eg.db)
# Corremos esto para veer cuales ENTERID estan duplicados
entrez_duplicados <- mapIds(org.Dm.eg.db,
keys= row.names(lrt$table),
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
# Quitamos de la tabla a quellos FLYID que referencien al mismo ENTREZID y a aquellos FLYID que no tengan un ENTREZID (es decir que haya un NA).
lrt$table <- lrt$table[!duplicated(entrez_duplicados),]
lrt$table <- lrt$table[-13,]
# Obtenemos ahora si los ENTREZID que tienen su analogo con FLYID
entrez <- mapIds(org.Dm.eg.db,
keys= row.names(lrt$table),
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
# Asignamos estos ENTERID como nombre de las columnas de la tabla anterior.
rownames(lrt$table) <- entrez
# Cargamos una libreria para obtener un enriquecimiento por GO
library(GO.db)
## Biological Process
go <- goana(lrt, species="Dm")
topGO(go, ont="BP", sort="Up", n=30, truncate=30)
## Molecular Function
go <- goana(lrt, species="Dm")
topGO(go, ont="MF", sort="Up", n=30, truncate=30)
## Cellular component
go <- goana(lrt, species="Dm")
topGO(go, ont="CC", sort="Up", n=30, truncate=30)
# Hacer el heatmap
heatmap.2(highly_variable_lcpm, col=rev(morecols(20)),trace="none", main="Top 20 más variables entre las muestras",  scale="row", cexCol = 0.8)
# Hacer el heatmap
heatmap.2(highly_variable_lcpm, col=rev(morecols(20)),trace="none", main="Top 20 más variables entre las muestras",  scale="row", cexCol = 0.65)
# Hacer el heatmap
heatmap.2(highly_variable_lcpm, col=rev(morecols(20)),trace="none", main="Top 20 más variables entre las muestras",  scale="row", cexCol = 0.6)
install.packages("caTools")
# Importar el dataset
dataset = read.csv('/home/kevinml/Documentos/Udemy/machinelearning-az/datasets/Part 2 - Regression/Section 5 - Multiple Linear Regression/50_Startups.csv')
View(dataset)
library(caTools)
set.seed(123)
split = sample.split(dataset$Profit, SplitRatio = 0.8)
training_set = subset(dataset, split == TRUE)
testing_set = subset(dataset, split == FALSE)
regression = lm(formula = Profit ~ .,
data = training_set)
summary(regression)
View(testing_set)
# Predecir los resultados con el conjunto de testing
y_pred = predict(regression, newdata = testing_set)
y_pred
View(testing_set)
SL = 0.05
regression = lm(formula = Profit ~ R.D.Spend + Administration + Marketing.Spend + State,
data = dataset)
summary(regression)
regression = lm(formula = Profit ~ R.D.Spend + Administration + Marketing.Spend,
data = dataset)
summary(regression)
regression = lm(formula = Profit ~ R.D.Spend + Marketing.Spend,
data = dataset)
summary(regression)
regression = lm(formula = Profit ~ R.D.Spend,
data = dataset)
summary(regression)
############################################################################
# ELIMINACION HACIA TRAS AUTOMATICA
backwardElimination <- function(x, sl) {
numVars = length(x)
for (i in c(1:numVars)){
regressor = lm(formula = Profit ~ ., data = x)
maxVar = max(coef(summary(regressor))[c(2:numVars), "Pr(>|t|)"])
if (maxVar > sl){
j = which(coef(summary(regressor))[c(2:numVars), "Pr(>|t|)"] == maxVar)
x = x[, -j]
}
numVars = numVars - 1
}
return(summary(regressor))
}
SL = 0.05
dataset = dataset[, c(1,2,3,4,5)]
backwardElimination(training_set, SL)
setwd("~/Documentos/Udemy/machinelearning-az/datasets/Part 2 - Regression/Section 6 - Polynomial Regression")
dataset = read.csv('Position_Salaries.csv')
View(dataset)
dataset = dataset[, 2:3]
lin_reg = lm(formula = Salary ~ .,
data = dataset)
summary(lin_reg)
# Ajustar Modelo de Regresión Polinómica con el Conjunto de Datos
dataset$Level2 = dataset$Level^2
dataset$Level3 = dataset$Level^3
dataset$Level4 = dataset$Level^4
poly_reg = lm(formula = Salary ~ .,
data = dataset)
summary(lin_reg)
setwd("~/Documentos/Udemy/machinelearning-az/datasets/Part 2 - Regression/Section 6 - Polynomial Regression")
dataset = read.csv('Position_Salaries.csv')
dataset = dataset[, 2:3]
#################################################################################
### Dividir el data set en conjunto de entrenamiento y conjunto de testing    ###
#################################################################################
# En este caso no vamos a dvidir nuestro conjunto de datos, ya que contamos con
# un escaso numero de observaciones. No hay la suficiente informacion para
# entrenar un modelo. Ademas en este cas buscamos hacer una interpolacion
# para predecir el sueldo de un empleado entre estos niveles.
# Sin embargo este paso es escencial.
# library(caTools)
# set.seed(123)
# split = sample.split(dataset$Purchased, SplitRatio = 0.8)
# training_set = subset(dataset, split == TRUE)
# testing_set = subset(dataset, split == FALSE)
################################################
#            Escalado de variables             #
################################################
# training_set[,2:3] = scale(training_set[,2:3])
# testing_set[,2:3] = scale(testing_set[,2:3])
##################################################
#      REFUTACION LA Ho (REGRESION LINEAL)       #
##################################################
# Generamos una regresion lineal para ver lo que pasa cuando se intenta
# ajustar datos que no son lineales. veremos despues como regresa la cosa
# con una regresion lineal polinomica.
# Ajustar Modelo de Regresión Lineal con el Conjunto de Datos
lin_reg = lm(formula = Salary ~ .,
data = dataset)
summary(lin_reg)
# Con la parte de Estimate Std. nos podemos dar cuenta de que el modelo no es el
# mejor. Intercept es en -195,333, ¿lo que significaria que para entrar a la empresa
# abria que pagar?. Tambien nos dice esto que al aumentar cada nivel se te
# pagan $80,879 mas, lo cual no coincide con los datos.
############################################################
##  Ajustar la regresión polinómica con todo el dataset    #
############################################################
# Ajustar Modelo de Regresión Polinómica con el Conjunto de Datos
# Le damos tratamiento a las variables independientes, construimos los terminos
# del polinomio de forma explicita, para que haya tantas columnas de la variable
# independiente como grados del polinomio.
dataset$Level2 = dataset$Level^2
dataset$Level3 = dataset$Level^3
dataset$Level4 = dataset$Level^4
poly_reg = lm(formula = Salary ~ .,
data = dataset)
summary(lin_reg)
summary(poly_reg)
library(ggplot2)
ggplot() +
geom_point(aes(x = dataset$Level , y = dataset$Salary),
color = "red") +
# Al momento de hacer la prediccion, en "newdata", con pasarle todo el dataset
# es  suficiente, automaticamente toma la variable independiente de definimos
# al generar nuestro modelo de regresion lineal, unicamente la columna tiene
# que tener el mismo nombre que el dataset usado para crear el modelo.
geom_line(aes(x = dataset$Level, y = predict(lin_reg, newdata = dataset)),
color = "blue") +
ggtitle("Predicción lineal del suedlo en función del nivel del empleado") +
xlab("Nivel del empleado") +
ylab("Sueldo (en $)")
# Predicción de nuevos resultados con Regresión Lineal
# Generamos un dataframe para que lo acepte la funcion, cuya unica fila es "Level"
# (mismo nombre de la columna del dataset con el que se creo el modelo).
y_pred = predict(lin_reg, newdata = data.frame(Level = 6.5))
# Predicción de nuevos resultados con Regresión Lineal
# Generamos un dataframe para que lo acepte la funcion, cuya unica fila es "Level"
# (mismo nombre de la columna del dataset con el que se creo el modelo).
# Si en level colucamos un vector (columnas)
y_pred = predict(lin_reg, newdata = data.frame(Level = c(6.5,5))
)
# Predicción de nuevos resultados con Regresión Lineal
# Generamos un dataframe para que lo acepte la funcion, cuya unica fila es "Level"
# (mismo nombre de la columna del dataset con el que se creo el modelo).
# Si en level colucamos un vector (columnas)
y_pred = predict(lin_reg, newdata = data.frame(Level = c(6.5,5,6)))
dataset$Level2 = dataset$Level^2
dataset$Level3 = dataset$Level^3
dataset$Level4 = dataset$Level^4
dataset$Level4 = dataset$Level^5
dataset$Level4 = dataset$Level^6
poly_reg = lm(formula = Salary ~ .,
data = dataset)
summary(poly_reg)
x_grid = seq(min(dataset$Level), max(dataset$Level), 0.1)
ggplot() +
geom_point(aes(x = dataset$Level , y = dataset$Salary),
color = "red") +
geom_line(aes(x = x_grid, y = predict(poly_reg,
newdata = data.frame(Level = x_grid,
Level2 = x_grid^2,
Level3 = x_grid^3,
Level4 = x_grid^4,
Level4 = x_grid^5,
Level4 = x_grid^6))),
color = "blue") +
ggtitle("Predicción polinómica del sueldo en función del nivel del empleado") +
xlab("Nivel del empleado") +
ylab("Sueldo (en $)")
dataset$Level2 = dataset$Level^2
dataset$Level3 = dataset$Level^3
dataset$Level4 = dataset$Level^4
dataset$Level5 = dataset$Level^5
dataset$Level6 = dataset$Level^6
poly_reg = lm(formula = Salary ~ .,
data = dataset)
summary(poly_reg)
x_grid = seq(min(dataset$Level), max(dataset$Level), 0.1)
ggplot() +
geom_point(aes(x = dataset$Level , y = dataset$Salary),
color = "red") +
geom_line(aes(x = x_grid, y = predict(poly_reg,
newdata = data.frame(Level = x_grid,
Level2 = x_grid^2,
Level3 = x_grid^3,
Level4 = x_grid^4,
Level4 = x_grid^5,
Level4 = x_grid^6))),
color = "blue") +
ggtitle("Predicción polinómica del sueldo en función del nivel del empleado") +
xlab("Nivel del empleado") +
ylab("Sueldo (en $)")
x_grid = seq(min(dataset$Level), max(dataset$Level), 0.1)
ggplot() +
geom_point(aes(x = dataset$Level , y = dataset$Salary),
color = "red") +
geom_line(aes(x = x_grid, y = predict(poly_reg,
newdata = data.frame(Level = x_grid,
Level2 = x_grid^2,
Level3 = x_grid^3,
Level4 = x_grid^4,
Level5 = x_grid^5,
Level6 = x_grid^6))),
color = "blue") +
ggtitle("Predicción polinómica del sueldo en función del nivel del empleado") +
xlab("Nivel del empleado") +
ylab("Sueldo (en $)")
install.packages("e1071")
